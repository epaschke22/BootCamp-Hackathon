{"ast":null,"code":"import { useReducer, useRef, useEffect, useMemo, useLayoutEffect } from 'react';\nimport invariant from 'invariant';\nimport { useReduxContext } from './useReduxContext';\nimport Subscription from '../utils/Subscription'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\n\n\nexport function useSelector(selector, equalityFn) {\n  if (equalityFn === void 0) {\n    equalityFn = refEquality;\n  }\n\n  invariant(selector, \"You must pass a selector to useSelectors\");\n\n  var _useReduxContext = useReduxContext(),\n      store = _useReduxContext.store,\n      contextSub = _useReduxContext.subscription;\n\n  var _useReducer = useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      forceRender = _useReducer[1];\n\n  var subscription = useMemo(function () {\n    return new Subscription(store, contextSub);\n  }, [store, contextSub]);\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef();\n  var latestSelectedState = useRef();\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(store.getState());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    var errorMessage = \"An error occured while selecting the store state: \" + err.message + \".\";\n\n    if (latestSubscriptionCallbackError.current) {\n      errorMessage += \"\\nThe error may be correlated with this previous error:\\n\" + latestSubscriptionCallbackError.current.stack + \"\\n\\nOriginal stack trace:\";\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(store.getState());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender({});\n    }\n\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    return function () {\n      return subscription.tryUnsubscribe();\n    };\n  }, [store, subscription]);\n  return selectedState;\n}","map":{"version":3,"names":["useReducer","useRef","useEffect","useMemo","useLayoutEffect","invariant","useReduxContext","Subscription","useIsomorphicLayoutEffect","window","refEquality","a","b","useSelector","selector","equalityFn","_useReduxContext","store","contextSub","subscription","_useReducer","s","forceRender","latestSubscriptionCallbackError","latestSelector","latestSelectedState","selectedState","current","getState","err","errorMessage","message","stack","Error","undefined","checkForUpdates","newSelectedState","onStateChange","trySubscribe","tryUnsubscribe"],"sources":["/home/wasadmin/project/tldp-client-react/node_modules/react-redux/es/hooks/useSelector.js"],"sourcesContent":["import { useReducer, useRef, useEffect, useMemo, useLayoutEffect } from 'react';\nimport invariant from 'invariant';\nimport { useReduxContext } from './useReduxContext';\nimport Subscription from '../utils/Subscription'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\n\n\nexport function useSelector(selector, equalityFn) {\n  if (equalityFn === void 0) {\n    equalityFn = refEquality;\n  }\n\n  invariant(selector, \"You must pass a selector to useSelectors\");\n\n  var _useReduxContext = useReduxContext(),\n      store = _useReduxContext.store,\n      contextSub = _useReduxContext.subscription;\n\n  var _useReducer = useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      forceRender = _useReducer[1];\n\n  var subscription = useMemo(function () {\n    return new Subscription(store, contextSub);\n  }, [store, contextSub]);\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef();\n  var latestSelectedState = useRef();\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(store.getState());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    var errorMessage = \"An error occured while selecting the store state: \" + err.message + \".\";\n\n    if (latestSubscriptionCallbackError.current) {\n      errorMessage += \"\\nThe error may be correlated with this previous error:\\n\" + latestSubscriptionCallbackError.current.stack + \"\\n\\nOriginal stack trace:\";\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(store.getState());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender({});\n    }\n\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    return function () {\n      return subscription.tryUnsubscribe();\n    };\n  }, [store, subscription]);\n  return selectedState;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}